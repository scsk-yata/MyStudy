Nsc = 32; %サブキャリヤ数（SP変換器出力）
N_GI = 8; %ガードインターバルの長さ
Lpilot = 2; %パイロットシンボル長
NofdmSymbol = 500; %OFDMシンボル数
Ndata = Nsc*NofdmSymbol; %データビット数[bit]
SNRdB = 20; %SN比[dB]
Delay = [0,8]; %遅延波の遅延量[chip]
Npath = length(Delay); %フェージング経路数（＝Delayの長さ）
data =  MYrndCode([Ndata,1],0);
bpskSymbol = MYbpskMod(data);
Nsymbol = length(bpskSymbol);
spOut = reshape(bpskSymbol,Nsc,NofdmSymbol); %（ア）S/P変換器
pilotMat = ones(Nsc,Lpilot);%（イ）パイロットシンボルをサブキャリヤ数分だけ複製
ofdmSymbol_pilot = ifft([pilotMat,spOut]); %（ウ）パイロットシンボルとともにIFFTに入力
gi = ofdmSymbol_pilot((end-N_GI+1):end,:); %（エ）ガードインターバルの作成
ofdmSymbol_pilot_GI = [gi;ofdmSymbol_pilot]; %（エ）ガードインターバルを付加
sOFDM = ofdmSymbol_pilot_GI(:); %（オ）P/S変換器
ofdmSymbolMat = sOFDM * ones(1,Npath);
ofdmSymbolMatDelayed = MYdelayGen(Delay, ofdmSymbolMat);
chOut = ofdmSymbolMatDelayed * ones(Npath,1);
Pn = 10^(-SNRdB/10) /Nsc;
rSig = chOut + MYawgn(Pn,length(chOut),1);
spOutR = reshape(rSig,(Nsc+N_GI),(Lpilot+NofdmSymbol)); %（カ）S/P変換器
spOutR(1:N_GI,:) = []; %（キ）ガードインターバル（GI）除去
fftOut = fft(spOutR); %（ク）FFT
pilotMatRx = fftOut(:,1:Lpilot); %（ケ）パイロットシンボルの抽出
ofdmSymbolRx = fftOut(:,(Lpilot+1):end); %ofdmシンボルからデータの抽出
chCoeff = mean(pilotMatRx,2);
phaseShift = chCoeff./abs(chCoeff) * ones(1,NofdmSymbol); %（コ）位相変化量の推定
ofdmSymbolRxCompensated = ofdmSymbolRx .* conj(phaseShift);%（サ）位相補償
rData = MYbpskDem(MYvec(ofdmSymbolRxCompensated));
BER = MYber(data,rData)
